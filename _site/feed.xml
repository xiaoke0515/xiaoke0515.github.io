<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.6">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2021-02-25T21:42:25+08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yilong Zhao</title><subtitle>My site is built on Nov. 24, 2019. It is used to record something I am interested in.</subtitle><author><name>Yilong Zhao</name></author><entry><title type="html">神经网络二阶优化总结</title><link href="http://localhost:4000/2021/02/25/1_NN_2rd_optimal/" rel="alternate" type="text/html" title="神经网络二阶优化总结" /><published>2021-02-25T19:43:00+08:00</published><updated>2021-02-25T19:43:00+08:00</updated><id>http://localhost:4000/2021/02/25/1_NN_2rd_optimal</id><content type="html" xml:base="http://localhost:4000/2021/02/25/1_NN_2rd_optimal/">&lt;p&gt;最近在看神经网络的二阶优化，总结一下看过的现有技术。从牛顿法到自然梯度法，再到现在的 Mindspore框架。&lt;/p&gt;

&lt;h1 id=&quot;牛顿法&quot;&gt;牛顿法&lt;/h1&gt;

&lt;h2 id=&quot;基础算法牛顿法&quot;&gt;基础算法：牛顿法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;牛顿法&lt;/strong&gt;是一个比较传统的二阶优化方法，具体细节与推导可以参考一些教材 &lt;sup id=&quot;fnref:sun_optimal&quot;&gt;&lt;a href=&quot;#fn:sun_optimal&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。
由于在对参数更新时参考了二阶的梯度，因此相比于一阶优化算法，可以更快地找到梯度下降的方向。
牛顿法的梯度下降更新公式为：&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;w_{k+1}=w_k+\alpha H_k^{-1} \nabla_w J_{k}&lt;/script&gt;&lt;br /&gt;
其中， $w$ 为权值， $H$ 代表 Hessian 矩阵（二阶梯度）， $J$ 为Jacobian 矩阵（一阶梯度）， 角标 $k$ 表示迭代的次数。
$\alpha$ 用于调节步长，也就是说，这个公式实际上已经是牛顿法的一个衍生算法，即&lt;strong&gt;带步长的牛顿法&lt;/strong&gt;。
这是由于对于非二阶凸优化问题，原始的牛顿法不一定能直接到位，故由牛顿法得到优化方向，再另外设置步长。
由于本文就针对的就是非二阶优化问题，因此在本文中我们就以这种带步长的牛顿法为基础算法进行讨论。&lt;/p&gt;

&lt;p&gt;牛顿法在实际应用时有一个重大缺陷，就是计算复杂度太大。
这个问题就出在表示二阶梯度的 Hessian 矩阵上。
问题可以总结为以下三点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;问题一： Hessian 矩阵大小过大&lt;/p&gt;

    &lt;p&gt;根据 Hessian 阵的定义我们可以知道， Hessian 阵的大小为参数量的平方。
 以一个比较常见的神经网络 ResNet-50 为例， 它的参数量大概在 25MB 左右（这个数我只是简单搜了一下，具体多少待考证），那么对应的 Hessian 阵的大小就是 5PB 。
 这个参数量别说 GPU ，硬盘都放不下。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;问题二： Hessian 矩阵求逆困难&lt;/p&gt;

    &lt;p&gt;这个问题有一部分原因是 Hessian 矩阵过大，然而矩阵求逆本身就是一个费计算资源的操作。
 无论是一些分解算法（如 SVG 分解），还是利用优化方法迭代，都需要大量计算。
 好在 Hessian 矩阵是一个对称方阵，但这似乎也不会改善任何现状。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;问题三： 神经网络的 Hessian 矩阵本身求解困难&lt;/p&gt;

    &lt;p&gt;一阶的 Jacobian 矩阵可以利用反向传播的方式求解，但二阶的 Hessian 矩阵就困难了。
 这是因为 Jacobian 矩阵在不同层之间是无关的，而 Hessian 不同。
 因此在计算 Hessian 阵时，只能以一个奇怪的顺序来传播&lt;sup id=&quot;fnref:Mizutani_second&quot;&gt;&lt;a href=&quot;#fn:Mizutani_second&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。
 如果说一阶的 Jacobian 矩阵的反向传播的顺序是以一个一维的轴从右向左计算，那么二阶的 Hessian 矩阵的反向传播就是二维的平面从右下到左上传播。
 此外，传播过程中计算 Hessian 阵的复杂程度远超 Jacobian 矩阵。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;拟牛顿法&quot;&gt;拟牛顿法&lt;/h2&gt;

&lt;p&gt;上一节中提到的牛顿法在实际应用时有一个重大缺陷，就是
现有的拟牛顿法主要有两种，分别为 &lt;strong&gt;DFP 法&lt;/strong&gt;和 &lt;strong&gt;BFGS 法&lt;/strong&gt;。
两种方法也是传统的方法了，针对的就是后两个问题，作了如下优化：&lt;strong&gt;不直接求解 Hessian 阵，而是在每次迭代过程中估计一个新老 Hessian 阵的差值，且假定这个差值矩阵的秩为 2&lt;/strong&gt; &lt;sup id=&quot;fnref:sun_optimal:1&quot;&gt;&lt;a href=&quot;#fn:sun_optimal&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。
这样就可以减少计算 Hessian 阵的复杂度，且摆脱了求逆的困扰。
其中， DFP 法直接在 Hessian 阵的逆阵上更新秩 2 矩阵， BFGS 在 Hessian 阵上更新秩 2 矩阵。
由于 DFP 算法在收敛性证明上缺失，且在数值上有缺陷，因此 BFGS 应用更广泛 &lt;sup id=&quot;fnref:DFP_fault&quot;&gt;&lt;a href=&quot;#fn:DFP_fault&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;BFGS 算法依旧面临着 Hessian 矩阵过大的问题，因此衍生出了 &lt;strong&gt;L-BFGS 算法&lt;/strong&gt; &lt;sup id=&quot;fnref:sun_optimal:2&quot;&gt;&lt;a href=&quot;#fn:sun_optimal&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。
其中的 L 就表示所需的 memory 更 low 。
它的思想是不存储 Hessian 阵，而是只存储 BFGS 算法中近几次迭代的秩 2 矩阵。
之后，将这些秩 2 矩阵作用在单位阵上近似成 Hessian 阵。
之所以可以减少存储，是因为秩 2 矩阵在存储时可以无损压缩得很少。
（但这种方法没人用，我猜可能是效果不好吧，具体可能得试一下才能知道。）&lt;/p&gt;

&lt;h2 id=&quot;levenberg-marquardt-法&quot;&gt;Levenberg-Marquardt 法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;L-M 算法&lt;/strong&gt;是针对二阶回归问题的一种牛顿法，恰好适合于损失函数为交叉熵的神经网络。
此方法中的 $H$ 矩阵被近似成了如下的形式：&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;H=\dfrac{1}{C}\mathcal{I} + \dfrac{1}{l}\sum_{i=1}^l\left(j^i\right)^TJ^i&lt;/script&gt;&lt;br /&gt;
也就是说，不必求解 Hessian 阵，求得 Jacobian 矩阵就可以了。 
但是这个方法的局限也很明显，效果也不如一阶算法 &lt;sup id=&quot;fnref:Wang_Distrubuted&quot;&gt;&lt;a href=&quot;#fn:Wang_Distrubuted&quot; class=&quot;footnote&quot;&gt;4&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;L-M 算法的推导&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;y=1&lt;/script&gt; 
to be continue…&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;自然梯度法&quot;&gt;自然梯度法&lt;/h1&gt;

&lt;p&gt;自然梯度法是&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:sun_optimal&quot;&gt;
      &lt;p&gt;孙文瑜, 徐成贤, 朱德通. 最优化方法[M]. Gao deng jiao yu chu ban she, 2004. &lt;a href=&quot;#fnref:sun_optimal&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt; &lt;a href=&quot;#fnref:sun_optimal:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; &lt;a href=&quot;#fnref:sun_optimal:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:Mizutani_second&quot;&gt;
      &lt;p&gt;E. Mizutani, S. E. Dreyfus, and J. W. Demmel, “Second-order backpropagation algorithms for a stagewise-partitioned separable Hessian matrix,” in Proceedings. 2005 IEEE International Joint Conference on Neural Networks, 2005., 2005: IEEE, doi: 10.1109/ijcnn.2005.1555994. &lt;a href=&quot;#fnref:Mizutani_second&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:DFP_fault&quot;&gt;
      &lt;p&gt;online: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/144736223&quot;&gt;https://zhuanlan.zhihu.com/p/144736223&lt;/a&gt; &lt;a href=&quot;#fnref:DFP_fault&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:Wang_Distrubuted&quot;&gt;
      &lt;p&gt;C.-C. Wang et al., “Distributed Newton Methods for Deep Neural Networks,” Neural Computation, vol. 30, no. 6, pp. 1673-1724, 2018-06-01 2018, doi: 10.1162/neco_a_01088. &lt;a href=&quot;#fnref:Wang_Distrubuted&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Yilong Zhao</name></author><category term="optimal_algorithm" /><summary type="html">最近在看神经网络的二阶优化，总结一下看过的现有技术。从牛顿法到自然梯度法，再到现在的 Mindspore框架。</summary></entry><entry><title type="html">SRAM-BNN 论文： Parallelizing SRAM Arrays with Customized Bit-Cell for Binary Neural Networks</title><link href="http://localhost:4000/2020/08/03/2_SRAM_BNN/" rel="alternate" type="text/html" title="SRAM-BNN 论文： Parallelizing SRAM Arrays with Customized Bit-Cell for Binary Neural Networks" /><published>2020-08-03T00:00:00+08:00</published><updated>2020-08-03T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/03/2_SRAM_BNN</id><content type="html" xml:base="http://localhost:4000/2020/08/03/2_SRAM_BNN/">&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default&quot;&gt;&lt;/script&gt;

&lt;blockquote&gt;
  &lt;p&gt;Rui Liu, Xiaochen Peng, Xiaoyu Sun, Win-San Khwa, Xin Si, Jia-Jing Chen, Jia-Fang Li, Meng-Fan Chang, and Shimeng Yu. 2018. Parallelizing SRAM arrays with customized bit-cell for binary neural networks. In Proceedings of the 55th Annual Design Automation Conference (DAC ’18). Association for Computing Machinery, New York, NY, USA, Article 21, 1–6. DOI:https://doi.org/10.1145/3195970.3196089.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The paper is &lt;a href=&quot;https://dl.acm.org/doi/pdf/10.1145/3195970.3196089,&quot; title=&quot;paper&quot;&gt;here&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Abstract first:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Recent advances in deep neural networks (DNNs) have shown Binary Neural Networks (BNNs) are able to provide a reasonable accuracy on various image datasets with a significant reduction in computation and memory cost. In this paper, we explore two BNNs: hybrid BNN (HBNN) and XNOR-BNN, where the weights are binarized to +1/-1 while the neuron activations are binarized to 1/0 and +1/-1 respectively. Two SRAM bit cell designs are proposed, namely, 6T SRAM for HBNN and customized 8T SRAM for XNOR-BNN. In our design, the high-precision multiply-and-accumulate (MAC) is replaced by bitwise multiplication for HBNN or XNOR for XNOR-BNN plus bit-counting operations. To parallelize the weighted sum operation, we activate multiple word lines in the SRAM array simultaneously and digitize the analog voltage developed along the bit line by a multi-level sense amplifier (MLSA). In order to partition the large matrices in DNNs, we investigate the impact of sensing bit-levels of MLSA on the accuracy degradation for different sub-array sizes and propose using the nonlinear quantization technique to mitigate the accuracy degradation. With 64×64 sub-array size and 3-bit MLSA, HBNN and XNOR-BNN architectures can minimize the accuracy degradation to 2.37% and 0.88%, respectively, for an inspired VGG-16 network on the CIFAR-10 dataset. Design space exploration of SRAM based synaptic architectures with the conventional row-by-row access scheme and our proposed parallel access scheme are also performed, showing significant benefits in the area, latency and energy-efficiency. Finally, we have successfully taped-out and validated the proposed HBNN and XNOR-BNN designs in TSMC 65 nm process with measured silicon data, achieving energy-efficiency &amp;gt;100 TOPS/W for HBNN and &amp;gt;50 TOPS/W for XNOR-BNN.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;contributions&quot;&gt;Contributions:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;XNOR-BNN complementary with costomized SRAM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Peripheral circuits which allow parallel access for SRAM&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Low accuracy degration and high energy saving&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;background&quot;&gt;Background:&lt;/h2&gt;

&lt;h3 id=&quot;hbnn-proposed&quot;&gt;HBNN (proposed)&lt;/h3&gt;

&lt;p&gt;Feature:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Weights: +1 / -1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Activations: 0 / 1&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;sram-cell&quot;&gt;SRAM Cell&lt;/h3&gt;

&lt;p&gt;Directly refer to the explicit figure:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ReRAM_DNN_accelerator/2_figure_SRAM_Cell.jpg&quot; alt=&quot;SRAM Cell&quot; width=&quot;500&quot; align=&quot;bottom&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;parallel-architecture&quot;&gt;Parallel Architecture&lt;/h2&gt;

&lt;p&gt;All the cells in the same column are opened by WLs.
Currents are accumulated at BLs, and the MAC operation is implemented.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/ReRAM_DNN_accelerator/2_figure_MAC.jpg&quot; alt=&quot;MAC&quot; width=&quot;500&quot; align=&quot;bottom&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;experiments--results&quot;&gt;Experiments &amp;amp; Results&lt;/h2&gt;

&lt;h3 id=&quot;accuracy&quot;&gt;Accuracy&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/ReRAM_DNN_accelerator/2_figure_Accuracy.jpg&quot; alt=&quot;MAC&quot; width=&quot;900&quot; align=&quot;bottom&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;performance&quot;&gt;Performance&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/ReRAM_DNN_accelerator/2_figure_Performance.jpg&quot; alt=&quot;MAC&quot; width=&quot;500&quot; align=&quot;bottom&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;chip&quot;&gt;Chip&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;/img/ReRAM_DNN_accelerator/2_figure_Chip.jpg&quot; alt=&quot;MAC&quot; width=&quot;900&quot; align=&quot;bottom&quot; /&gt;&lt;/p&gt;</content><author><name>Yilong Zhao</name></author><category term="ReRAM_paper" /><category term="analog computing" /><category term="analog signal processing" /><summary type="html"></summary></entry><entry><title type="html">GEM5- GEM5 中的 fatal 、 panic 、 warn</title><link href="http://localhost:4000/2020/08/02/6_GEM5_fatal_panic_warn/" rel="alternate" type="text/html" title="GEM5- GEM5 中的 fatal 、 panic 、 warn" /><published>2020-08-02T00:00:00+08:00</published><updated>2020-08-02T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/02/6_GEM5_fatal_panic_warn</id><content type="html" xml:base="http://localhost:4000/2020/08/02/6_GEM5_fatal_panic_warn/">&lt;p&gt;除了可以使用 assert 外， GEM5 中提供了三个用于检查的函数：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;fatal / falal_if&lt;/p&gt;

    &lt;p&gt;程序直接退出&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;panic / panic_ic&lt;/p&gt;

    &lt;p&gt;程序退出当前函数，继续执行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;warn / warn_if&lt;/p&gt;

    &lt;p&gt;程序报 warning ，继续执行&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Yilong Zhao</name></author><category term="GEM5" /><category term="GEM5" /><category term="simulator" /><category term="cycle accurate" /><summary type="html">除了可以使用 assert 外， GEM5 中提供了三个用于检查的函数：</summary></entry><entry><title type="html">GEM5- GEM5 给 SimObject 添加 Param</title><link href="http://localhost:4000/2020/08/01/3_GEM5_Param/" rel="alternate" type="text/html" title="GEM5- GEM5 给 SimObject 添加 Param" /><published>2020-08-01T00:00:00+08:00</published><updated>2020-08-01T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/01/3_GEM5_Param</id><content type="html" xml:base="http://localhost:4000/2020/08/01/3_GEM5_Param/">&lt;p&gt;先废话一下吧， GEM5 仿真器的代码组织是以 SimObject 为核心的。
以 CPU 和 memory 两类重要的模块为例，在各自的文件夹下定义了好多个 class ，每个 class 都以 SimObject 类为基类。
GEM5 提供了给 SimObject 添加参数的方式，在 &lt;a href=&quot;http://www.gem5.org/documentation/learning_gem5/part2/parameters/&quot;&gt;http://www.gem5.org/documentation/learning_gem5/part2/parameters/&lt;/a&gt; 中。
原理非常简单，在此不再完整描述，只介绍必要的部分。
随后将讨论一个重要的问题，如何定义一个复杂类型的参数。&lt;/p&gt;

&lt;h2 id=&quot;background&quot;&gt;BackGround&lt;/h2&gt;

&lt;h3 id=&quot;gem5-中的参数定义&quot;&gt;GEM5 中的参数定义&lt;/h3&gt;

&lt;p&gt;GEM5 中给一个 SimObject 定义一个参数有如下几个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;在 SimObject 对应的 .py 文件中添加参数&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     &lt;span class=&quot;n&quot;&gt;Param&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'The number of xxx'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 一个整数作为参数
&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;VectorParam&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([],&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'The number of xxxs'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 一个整数 vector 作为参数
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GEM5 编译器通过分析上述 .py 文件在 param 文件夹下生成与 SimObject 名字相同的 c++ 头文件，里面定义了 c++ 可引用的参数类型。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在我们写的 SimObject 的 c++ class 中，将 2 步骤中的参数类型传递给构造函数，就可以在构造函数中解析参数。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;gem5-中的参数类型&quot;&gt;GEM5 中的参数类型&lt;/h3&gt;

&lt;p&gt;我们先看一下 GEM5 中提供了哪几种参数。&lt;/p&gt;

&lt;p&gt;通过观察 GEM5 中定义参数的步骤，可以分析出来 GEM5 是通过某种方式将 python 中的数据类型和 c++ 中的数据类型打通，进而完成将 python config 脚本中的参数传递给 c++ 代码的任务。
因此在 GEM5 的源码中，默认参数类型在 c++ 文件和 python 文件分别定义了一份。
c++ 文件为 base/types.hh ， python 文件为 python/m5/params.py 。&lt;/p&gt;

&lt;p&gt;下面的列表我们将描述 python 文件中定义的数据类型，并列出对应的 c++ 数据类型：&lt;/p&gt;

&lt;table align=&quot;center&quot; border=&quot;1&quot; frame=&quot;box&quot;&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;Python 类型&lt;/th&gt; 
        &lt;th&gt;c++ 类型&lt;/th&gt; 
        &lt;th&gt;c++ 头文件&lt;/th&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;Int&lt;/th&gt;
        &lt;td&gt;std::string&lt;/td&gt;
        &lt;td&gt;内置类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;(U)Int(8,16...)&lt;/th&gt;
        &lt;td&gt;(u)int(8,16...)_t&lt;/td&gt;
        &lt;td&gt;内置类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;Float&lt;/th&gt;
        &lt;td&gt;double&lt;/td&gt;
        &lt;td&gt;内置类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;Bool&lt;/th&gt;
        &lt;td&gt;bool&lt;/td&gt;
        &lt;td&gt;内置类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;Counter&lt;/th&gt;
        &lt;td&gt;Counter&lt;/td&gt;
        &lt;td&gt;base/type.hh&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;Tick&lt;/th&gt;
        &lt;td&gt;Tick&lt;/td&gt;
        &lt;td&gt;base/type.hh&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;TcpPort / UdpPort&lt;/th&gt;
        &lt;td&gt;uint16_t&lt;/td&gt;
        &lt;td&gt;内置类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;Percent&lt;/th&gt;
        &lt;td&gt;int&lt;/td&gt;
        &lt;td&gt;内置类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;Cycles&lt;/th&gt;
        &lt;td&gt;Cycles&lt;/td&gt;
        &lt;td&gt;base/type.hh&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;MemorySize / MemorySize32&lt;/th&gt;
        &lt;td&gt;uint64_t&lt;/td&gt;
        &lt;td&gt;内置类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;Addr&lt;/th&gt;
        &lt;td&gt;Addr&lt;/td&gt;
        &lt;td&gt;base/type.hh&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;AddrRange&lt;/th&gt;
        &lt;td&gt;AddrRange&lt;/td&gt;
        &lt;td&gt;base/addr_range.hh&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;EthernetAddr&lt;/th&gt;
        &lt;td&gt;Net::EthAddr&lt;/td&gt;
        &lt;td&gt;base/inet.hh&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;IpAddress&lt;/th&gt;
        &lt;td&gt;Net::IpAddress&lt;/td&gt;
        &lt;td&gt;base/inet.hh&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;IpNetmask&lt;/th&gt;
        &lt;td&gt;Net::IpNetmask&lt;/td&gt;
        &lt;td&gt;base/inet.hh&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;IpWithPort&lt;/th&gt;
        &lt;td&gt;Net::IpWithPort&lt;/td&gt;
        &lt;td&gt;base/inet.hh&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;Time&lt;/th&gt;
        &lt;td&gt;tm&lt;/td&gt;
        &lt;td&gt;base/time.hh&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;TickParamValue / Latency / Frequency / Clock&lt;/th&gt;
        &lt;td&gt;Tick&lt;/td&gt;
        &lt;td&gt;base/types.hh&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;Voltage / Current / Energy / NetworkBandwidth / MemoryBandwidth&lt;/th&gt;
        &lt;td&gt;double&lt;/td&gt;
        &lt;td&gt;内置类型&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr align=&quot;center&quot;&gt;
        &lt;th&gt;NullSimObject&lt;/th&gt;
        &lt;td&gt;Null&lt;/td&gt;
        &lt;td&gt;内置类型&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;一般来说，上述的数据类型已经足够丰富，足够使用了。&lt;/p&gt;

&lt;h2 id=&quot;定义新的参数类型&quot;&gt;定义新的参数类型&lt;/h2&gt;

&lt;p&gt;在我的需求中实际上是要定义一个新的复杂的数据类型。
一种直观的方式是通过 SimObject 的嵌套来实现。
但是这种方式会多定义好多 SimObject ，增加编译时间。
因此我更希望通过仿照 GEM5 的源码中定义数据类型的方式来实现。
于是我看了下源码是如何定义的。&lt;/p&gt;

&lt;h3 id=&quot;gem5-源码中参数定义&quot;&gt;GEM5 源码中参数定义&lt;/h3&gt;

&lt;p&gt;以 AddrRange 类型为例：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;python 文件中的定义（python/m5/params.py)：&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AddrRange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ParamValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 以ParamValue为基类来定义一个数据类型
&lt;/span&gt;     &lt;span class=&quot;n&quot;&gt;cxx_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'AddrRange'&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;# 定义对应的 c++ class 名称
&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;**&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'end'&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
             &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Addr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kwargs&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pop&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'end'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;# 读取 kwargs
&lt;/span&gt;         &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
        
     &lt;span class=&quot;c1&quot;&gt;# 定义 python 方法 （可选）
&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;__str__&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;

     &lt;span class=&quot;c1&quot;&gt;# pybind_predecls 方法：
&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# 定义一个引用文件（即 AddrRange 对应的 c++ class 定义的位置）
&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# 这句 code 在某个使用 AddrRange 参数的 SimObject 生成的 build/X86/python/_m5/param_xxx.cc 中，会出现在引用头文件的部分
&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# build/X86/python/_m5/param_xxx.cc 文件是用于 SimObject 的 c++ 和 python 文件之间的 pybind
&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;classmethod&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;pybind_predecls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'#include &quot;base/addr_range.hh&quot;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

     &lt;span class=&quot;c1&quot;&gt;# cxx_predecls 方法：
&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# 定义一个引用文件（即 AddrRange 对应的 c++ class 定义的位置）
&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# 这句 code 在某个使用 AddrRange 参数的 SimObject 生成的 build/X86/params/xxx.hh 中，会出现在引用头文件的部分
&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# build/X86/params/xxx.hh 文件是用于定义 SimObject 的 c++ 语言的参数类型
&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;classmethod&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cxx_predecls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'#include &quot;base/addr_range.hh&quot;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

     &lt;span class=&quot;c1&quot;&gt;# cxx_ini_predecls 和 cxx_ini_parse 方法：（可选）
&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# 定义一个引用文件和sparse代码
&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# 这句 code 在由 .py 配置文件生成 .ini 配置文件时生成参数的信息
&lt;/span&gt;     &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;classmethod&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cxx_ini_predecls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'#include &amp;lt;vector&amp;gt;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

     &lt;span class=&quot;o&quot;&gt;@&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;classmethod&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;cxx_ini_parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cls&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;src&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dest&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt;
         &lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'${ret} _ret;'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

     &lt;span class=&quot;c1&quot;&gt;# 定义 getValue函数：
&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;# 这个是 python 和 c++ 代码之间联系的关键之一，这个含义我们在接下来pybind一节中介绍
&lt;/span&gt;     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
             &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;_m5.range&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AddrRange&lt;/span&gt; 

             &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AddrRange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                             &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;masks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intlvMatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;c++ 文件中的定义(base/addr_range.hh)：&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AddrRange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
     &lt;span class=&quot;c1&quot;&gt;// 定义私有成员变量，可自由发挥&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;Addr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
     &lt;span class=&quot;n&quot;&gt;Addr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
 &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;

     &lt;span class=&quot;c1&quot;&gt;// 定义构造函数&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;AddrRange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
         &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;AddrRange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Addr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Addr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...)&lt;/span&gt;
     &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;

     &lt;span class=&quot;c1&quot;&gt;// 定义其他方法，以下面这个为例&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

     &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 SConscript 文件中设置编译以上两个文件&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;PySource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'m5'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'m5/params.py'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;以及&lt;/p&gt;
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;Source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'types.cc'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;将两种语言定义的数据类型联系起来pybind&quot;&gt;将两种语言定义的数据类型联系起来（pybind）&lt;/h3&gt;

&lt;p&gt;GEM5 中将两种语言的数据类型联系起来的关键是利用 pybind，与 AddrRange 相关的代码在 python/pybind11/core.cc 文件中定义：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先定义一个 python module ， 名为 core.range：
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
 &lt;span class=&quot;nf&quot;&gt;pybind_init_core&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_native&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_core&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_native&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;def_submodule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;core&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
        
     &lt;span class=&quot;c1&quot;&gt;// 调用下面的函数定义一个子模块 core.range&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;init_range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_native&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

 &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;
 &lt;span class=&quot;nf&quot;&gt;init_range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_native&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_native&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;def_submodule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;range&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

     &lt;span class=&quot;c1&quot;&gt;// 绑定数据类型 AddrRange&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;class_&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddrRange&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;AddrRange&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;def&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// 绑定构造函数&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;def&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Addr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 绑定另一个构造函数&lt;/span&gt;
         &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;//&lt;/span&gt;

         &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;def&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;__str__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddrRange&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;// 将 python 文件中定义的 __str__ 函数与 c++ 文件中定义的 to_string 函数绑定&lt;/span&gt;

 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将 core 模块挂载到 _m5 模块下&lt;/p&gt;

    &lt;p&gt;在 sim/init.cc 文件中，已经定义了 _m5 模块。在这个文件的如下代码中，调用了上述 pybind_init_core 函数，将 range 挂载到了 _m5 模块下：&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;EmbeddedPyBind&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initAll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EmbeddedPyBind&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pending&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

     &lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_m5&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;module&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;_m5&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;m_m5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;attr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;__package__&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;py&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cast&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;_m5&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

     &lt;span class=&quot;n&quot;&gt;pybind_init_core&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_m5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 python 定义的 AddrRange 中定义 getValue 函数&lt;/p&gt;

    &lt;p&gt;回头再说之前代码中的 getValue函数：&lt;/p&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;     &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
         &lt;span class=&quot;kn&quot;&gt;from&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;_m5.range&lt;/span&gt; &lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AddrRange&lt;/span&gt; 

         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;AddrRange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;long&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                         &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;masks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;intlvMatch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;现在可以理解，这实际上是引用了 _m5 模块中的 c++ 类型 AddrRange，并调用它的构造函数，返回一个 c++ 类型的 AddrRange。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;在任意位置定义新的参数&quot;&gt;在任意位置定义新的参数&lt;/h2&gt;

&lt;p&gt;我的习惯是将改动都放在自己的文件夹下，这就要实现在任意位置定义新的参数。这里其实也算是个步骤总结：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;定义一个 c++ class （参考上面的代码）&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;定义构造函数，与其他函数&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在 SConscript 中设置编译：&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;Source&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'xxx.cc'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;利用 pybind 将上述 c++ 类转换成 python 库（参考上面的代码）&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;定义一个子模块 init 函数&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在上述函数中将 c++ 类绑定成 python module&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在 sim/init.cc 的对应位置调用上述函数 （这里不得不修改源码）&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;定义一个 python class （参考上面的代码）&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;定义 cxx_type&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;定义构造函数，读取 kwargs&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;定义 pybind_predecls 、 cxx_predecls 、 cxx_ini_predecls 、 cxx_ini_parse ，后两者可选&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;定义 getValue ，返回 pybind 中绑定的 c++ 类&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在 SConscript 中将这个文件挂载到 m5 模块下：&lt;/p&gt;

        &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;PySource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'m5'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'xxx.py'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Yilong Zhao</name></author><category term="GEM5" /><category term="GEM5" /><category term="simulator" /><category term="cycle accurate" /><summary type="html">先废话一下吧， GEM5 仿真器的代码组织是以 SimObject 为核心的。 以 CPU 和 memory 两类重要的模块为例，在各自的文件夹下定义了好多个 class ，每个 class 都以 SimObject 类为基类。 GEM5 提供了给 SimObject 添加参数的方式，在 http://www.gem5.org/documentation/learning_gem5/part2/parameters/ 中。 原理非常简单，在此不再完整描述，只介绍必要的部分。 随后将讨论一个重要的问题，如何定义一个复杂类型的参数。</summary></entry><entry><title type="html">GEM5- GEM5 中 SimObject 多继承的问题</title><link href="http://localhost:4000/2020/08/01/4_GEM5_MultiInherent/" rel="alternate" type="text/html" title="GEM5- GEM5 中 SimObject 多继承的问题" /><published>2020-08-01T00:00:00+08:00</published><updated>2020-08-01T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/01/4_GEM5_MultiInherent</id><content type="html" xml:base="http://localhost:4000/2020/08/01/4_GEM5_MultiInherent/">&lt;p&gt;之前遇到了一个比较蠢的问题，记录一下。&lt;/p&gt;

&lt;p&gt;在定义一个 SimObject 时，突发奇想搞了个多继承，即既继承 SimObject 和另一个基类。
就这样出了问题。
观察 python/m5/simulate.py/instantiate() 发现，在实例化的过程中调用了基类中的函数，导致运行的错误。&lt;/p&gt;

&lt;p&gt;所以&lt;/p&gt;

&lt;h2 id=&quot;不要用多继承&quot;&gt;&lt;strong&gt;不要用多继承&lt;/strong&gt;&lt;/h2&gt;</content><author><name>Yilong Zhao</name></author><category term="GEM5" /><category term="GEM5" /><category term="simulator" /><category term="cycle accurate" /><summary type="html">之前遇到了一个比较蠢的问题，记录一下。</summary></entry><entry><title type="html">GEM5- GEM5 中 VectorPort 的用法</title><link href="http://localhost:4000/2020/08/01/5_GEM5_VectorPortUsage/" rel="alternate" type="text/html" title="GEM5- GEM5 中 VectorPort 的用法" /><published>2020-08-01T00:00:00+08:00</published><updated>2020-08-01T00:00:00+08:00</updated><id>http://localhost:4000/2020/08/01/5_GEM5_VectorPortUsage</id><content type="html" xml:base="http://localhost:4000/2020/08/01/5_GEM5_VectorPortUsage/">&lt;p&gt;我的需求用到不确定个数的 port ，看了源码搞清了应该怎么用。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在 SimObject 的 py 文件中添加：
    &lt;div class=&quot;language-python highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;masterports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VectorMasterPort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'master ports'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;slaveports&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;VectorSlavePort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'slave ports'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 SimObject 的 hh 文件中添加 port 的 vector 变量：&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;XXXMasterPort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;XXXSlavePort&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SimObject 类中重写 getPort 函数：&lt;/p&gt;

    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;n&quot;&gt;Port&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;
 &lt;span class=&quot;n&quot;&gt;HyperTr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getPort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;if_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PortID&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;

     &lt;span class=&quot;c1&quot;&gt;// This is the name from the Python SimObject declaration (SimpleMemobj.py)&lt;/span&gt;
     &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;if_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;masterports&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;if_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;slaveports&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
         &lt;span class=&quot;c1&quot;&gt;// pass it along to our super class&lt;/span&gt;
         &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SimObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;getPort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;if_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;idx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
     &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在 c++ class 的构造函数中添加 vector ports：&lt;/p&gt;

    &lt;p&gt;port_xxx_connection_count 是自动生成的参数，是编译器根据 config.py 文件中连接了多少 port 确定的。
 在构造函数中，我们需要按照这个数量添加 port。&lt;/p&gt;
    &lt;div class=&quot;language-c++ highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port_masterports_connection_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;m_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;XXXMasterPort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;.m_port:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
 &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;port_slaveports_connection_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;){&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;s_ps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;push_back&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;XXXSlavePort&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;params&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;.s_port:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;to_string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
 &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;为了表示哪几个名字必须一样，哪几个名字不必一样，我特意将 c++ class 中 port 的名字与 python 中 port 的名字设置的不同。&lt;/p&gt;

&lt;p&gt;另：啰嗦一句&lt;/p&gt;

&lt;p&gt;其实重点在于 getPort 函数，这个函数用于定义 python 文件中的 port 名字与 c++ class 中的哪个 port 对应。
c++ class 中的 port 可能不必定义成一个 vector 。
只要能让 gem5 编译器找到对应的 port 即可。&lt;/p&gt;</content><author><name>Yilong Zhao</name></author><category term="GEM5" /><category term="GEM5" /><category term="simulator" /><category term="cycle accurate" /><summary type="html">我的需求用到不确定个数的 port ，看了源码搞清了应该怎么用。</summary></entry><entry><title type="html">GEM5- GEM5 的基础使用</title><link href="http://localhost:4000/2020/07/21/2_GEM5_Basic_Usage/" rel="alternate" type="text/html" title="GEM5- GEM5 的基础使用" /><published>2020-07-21T00:00:00+08:00</published><updated>2020-07-21T00:00:00+08:00</updated><id>http://localhost:4000/2020/07/21/2_GEM5_Basic_Usage</id><content type="html" xml:base="http://localhost:4000/2020/07/21/2_GEM5_Basic_Usage/">&lt;p&gt;参考文档 &lt;a href=&quot;http://www.gem5.org/&quot;&gt;http://www.gem5.org/&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;GEM5 的编译&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.gem5.org/documentation/learning_gem5/part1/building/&quot;&gt;http://www.gem5.org/documentation/learning_gem5/part1/building/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GEM5 的 config 文件&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.gem5.org/documentation/learning_gem5/part1/simple_config/&quot;&gt;http://www.gem5.org/documentation/learning_gem5/part1/simple_config/&lt;/a&gt;
  &lt;a href=&quot;http://www.gem5.org/documentation/learning_gem5/part1/cache_config/&quot;&gt;http://www.gem5.org/documentation/learning_gem5/part1/cache_config/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GEM5 的 output&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.gem5.org/documentation/learning_gem5/part1/gem5_stats/&quot;&gt;http://www.gem5.org/documentation/learning_gem5/part1/gem5_stats/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编写一个模块 （ SimObject ）&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.gem5.org/documentation/learning_gem5/part2/helloobject/&quot;&gt;http://www.gem5.org/documentation/learning_gem5/part2/helloobject/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;debug flag 的使用&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.gem5.org/documentation/learning_gem5/part2/debugging/&quot;&gt;http://www.gem5.org/documentation/learning_gem5/part2/debugging/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cycle accurate 的核心： event 的定义&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.gem5.org/documentation/learning_gem5/part2/events/&quot;&gt;http://www.gem5.org/documentation/learning_gem5/part2/events/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模块的参数定义&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.gem5.org/documentation/learning_gem5/part2/parameters/&quot;&gt;http://www.gem5.org/documentation/learning_gem5/part2/parameters/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模块间的数据交互： port 的定义&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.gem5.org/documentation/learning_gem5/part2/memoryobject/&quot;&gt;http://www.gem5.org/documentation/learning_gem5/part2/memoryobject/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一个例子： cache&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.gem5.org/documentation/learning_gem5/part2/simplecache/&quot;&gt;http://www.gem5.org/documentation/learning_gem5/part2/simplecache/&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;GEM5 中的 ruby&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;http://www.gem5.org/documentation/learning_gem5/part3/MSIintro/&quot;&gt;http://www.gem5.org/documentation/learning_gem5/part3/MSIintro/&lt;/a&gt;&lt;/p&gt;

    &lt;p&gt;这里开始我暂时用不上，还没有仔细看。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;</content><author><name>Yilong Zhao</name></author><category term="GEM5" /><category term="GEM5" /><category term="simulator" /><category term="cycle accurate" /><summary type="html">参考文档 http://www.gem5.org/</summary></entry><entry><title type="html">GEM5- GEM5 的非 sudo 用户安装</title><link href="http://localhost:4000/2020/07/20/1_GEM_Install/" rel="alternate" type="text/html" title="GEM5- GEM5 的非 sudo 用户安装" /><published>2020-07-20T00:00:00+08:00</published><updated>2020-07-20T00:00:00+08:00</updated><id>http://localhost:4000/2020/07/20/1_GEM_Install</id><content type="html" xml:base="http://localhost:4000/2020/07/20/1_GEM_Install/">&lt;p&gt;这篇是好久之前总结的，觉得网上没有相关的资料于是就把这个放上来了。算是比较详细，该踩的坑都踩了。&lt;/p&gt;

&lt;p&gt;需求：gem5仿真器要安装 scons ，需要无sudo权限使用 python-dev ；先试着求助 anaconda ，但无果，最终选择了这种方案。&lt;/p&gt;

&lt;p&gt;大致思路是用源码编译python，之后安装pip，再安装scons。&lt;/p&gt;

&lt;p&gt;当然，如果有 root 权限就简单很多了，直接参考官方文档 &lt;a href=&quot;http://www.gem5.org/&quot;&gt;http://www.gem5.org/&lt;/a&gt; 就可以了。&lt;/p&gt;

&lt;h2 id=&quot;python-和-python-dev-的安装&quot;&gt;Python 和 Python-dev 的安装&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;下载并编译python&lt;/p&gt;

    &lt;p&gt;scons对python版本需求是 python2.7，下安装 python2.7.17&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;源码地址： &lt;a href=&quot;https://www.python.org/downloads/source/&quot;&gt;https://www.python.org/downloads/source/&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;config：&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ./configure --enable-optimizations --prefix=~/.local/python2.7/（安装路径，可自定义）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;make：&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  make &amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;将python路径添加到.bashrc中：&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  export PATH=&quot;路径:$PATH&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译安装 pip 和 setuptools&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;源码地址： &lt;a href=&quot;https://pypi.org/project/setuptools/#files&quot;&gt;https://www.python.org/downloads/source/&lt;/a&gt; 和 &lt;a href=&quot;https://pypi.org/project/pip/#files&quot;&gt;https://pypi.org/project/pip/#files&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;install，注意这里要确认 python 为刚刚安装的 python ，如果不是，要尝试关闭 conda 等环境。&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;[2020-07-23 更新： setuptool会有版本问题，最新的版本不支持python2，要选择之前的版本]&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改pip源&lt;/p&gt;

    &lt;p&gt;几个可选的 PYPI 国内源路径:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;阿里云 &lt;a href=&quot;http://mirrors.aliyun.com/pypi/simple/&quot;&gt;http://mirrors.aliyun.com/pypi/simple/&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;豆瓣(douban) &lt;a href=&quot;http://pypi.douban.com/simple/&quot;&gt;http://pypi.douban.com/simple/&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;清华大学 &lt;a href=&quot;https://pypi.tuna.tsinghua.edu.cn/simple/&quot;&gt;https://pypi.tuna.tsinghua.edu.cn/simple/&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;中国科学技术大学 &lt;a href=&quot;http://pypi.mirrors.ustc.edu.cn/simple/&quot;&gt;http://pypi.mirrors.ustc.edu.cn/simple/&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;修改方式：在～/.pip/pip.conf文件中追加如下字段&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; [global]
 index-url=http://pypi.douban.com/simple
 [install]
 trusted-host=pypi.douban.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;scons-的安装&quot;&gt;scons 的安装&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;安装scons:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;源码地址 &lt;a href=&quot;https://github.com/SCons/scons&quot;&gt;https://github.com/SCons/scons&lt;/a&gt; ,  github上有安装步骤，可自行参考，不赘述&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;bootstrap 的安装：&lt;/p&gt;

        &lt;ul&gt;
          &lt;li&gt;
            &lt;p&gt;python bootstrap.py build/scons&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;install：&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cd build/scons
  python setup.py install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;[2020-07-23 更新： scons 会有版本问题，最新的版本不支持 python2 ，要选择之前的版本，亲测 3.1.2 之前的版本可以]&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;gem5的其他依赖&quot;&gt;GEM5的其他依赖&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;M4等： 此处参考 &lt;a href=&quot;https://blog.csdn.net/qq_30549833/article/details/72955881&quot;&gt;https://blog.csdn.net/qq_30549833/article/details/72955881&lt;/a&gt; ，下面的源网站可以根据情况改成最新的版本，四个都要安装在同一个文件夹下，建议安装在~/.local
    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;安装m4&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;地址:&lt;/p&gt;

            &lt;p&gt;&lt;a href=&quot;http://mirrors.kernel.org/gnu/m4/m4-1.4.13.tar.gz&quot;&gt;http://mirrors.kernel.org/gnu/m4/m4-1.4.13.tar.gz&lt;/a&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Config:&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ./configure –prefix=~/.local（或其他安装路径，下同）
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Install:&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;安装autoconf&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;地址:&lt;/p&gt;

            &lt;p&gt;&lt;a href=&quot;http://mirrors.kernel.org/gnu/autoconf/autoconf-latest.tar.gz&quot;&gt;http://mirrors.kernel.org/gnu/autoconf/autoconf-latest.tar.gz&lt;/a&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Config:&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ./configure –prefix=~/.local
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Install:&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;安装automake&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;地址:&lt;/p&gt;

            &lt;p&gt;&lt;a href=&quot;http://mirrors.kernel.org/gnu/automake/automake-1.11.tar.gz&quot;&gt;http://mirrors.kernel.org/gnu/automake/automake-1.11.tar.gz&lt;/a&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Config:&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ./configure –prefix=~/.local
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Install:&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;安装libtool&lt;/p&gt;

        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;地址:&lt;/p&gt;

            &lt;p&gt;&lt;a href=&quot;http://mirrors.kernel.org/gnu/libtool/libtool-2.2.6b.tar.gz&quot;&gt;http://mirrors.kernel.org/gnu/libtool/libtool-2.2.6b.tar.gz &lt;/a&gt;&lt;/p&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Config:&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; ./configure –prefix=~/.local
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;Install:&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; make &amp;amp;&amp;amp; make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Protobuf:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;源码地址： &lt;a href=&quot;https://github.com/protocolbuffers/protobuf.git&quot;&gt;https://github.com/protocolbuffers/protobuf.git&lt;/a&gt;&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Update： 这个步骤省了会报错&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  git submodule update --init --recursive
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;autogen：&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ./autogen.sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;config:&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  ./configure --prefix = {your_path}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;install:&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  make
  make check
  make install
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;添加路径在.bashrc文件中，在.bashrc中追加：&lt;/p&gt;

        &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  export PATH=&quot;{your_path}:$PATH&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;添加python依赖 （可选）：&lt;/p&gt;
        &lt;ol&gt;
          &lt;li&gt;
            &lt;p&gt;添加python路径 （就是刚才安装的python路径，添加到 PYTHONPATH 环境变量中）：&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; export PYTHONPATH=&quot;{your_path}/lib/python2.7/site-packages/:$PYTHONPATH&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;编译安装&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; python setup.py build 
 python setup.py test 
 python setup.py install --prefix={your_path} 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
          &lt;li&gt;
            &lt;p&gt;测试，打开一个python，输入下面代码，没有import错误就说明正确安装了&lt;/p&gt;

            &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; import google.protobuf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;            &lt;/div&gt;
          &lt;/li&gt;
        &lt;/ol&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;gem5-的编译&quot;&gt;GEM5 的编译&lt;/h2&gt;

&lt;p&gt;最后就可以编译 GEM5 啦&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;源码：&lt;/p&gt;

    &lt;p&gt;&lt;a href=&quot;https://github.com/gem5/gem5.git&quot;&gt;https://github.com/gem5/gem5.git&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编译gem5：&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; scons bulid/X86/gem5.opt -j9
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;p&gt;有可能会报错少一些 python module ，这个可以很轻松解决，在此不赘述。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>Yilong Zhao</name></author><category term="GEM5" /><category term="GEM5" /><category term="simulator" /><category term="cycle accurate" /><summary type="html">这篇是好久之前总结的，觉得网上没有相关的资料于是就把这个放上来了。算是比较详细，该踩的坑都踩了。</summary></entry><entry><title type="html">Candance 1： Candance的初步使用</title><link href="http://localhost:4000/2020/07/07/1_Candance_Intro/" rel="alternate" type="text/html" title="Candance 1： Candance的初步使用" /><published>2020-07-07T00:00:00+08:00</published><updated>2020-07-07T00:00:00+08:00</updated><id>http://localhost:4000/2020/07/07/1_Candance_Intro</id><content type="html" xml:base="http://localhost:4000/2020/07/07/1_Candance_Intro/">&lt;h2 id=&quot;candance的安装&quot;&gt;Candance的安装&lt;/h2&gt;

&lt;p&gt;使用的是已经安装好的 candance ，没有涉及到安装问题，留出位置，以后遇到问题再补。&lt;/p&gt;

&lt;h2 id=&quot;candance-启动&quot;&gt;Candance 启动&lt;/h2&gt;

&lt;p&gt;命令：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;virtuoso &amp;amp;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在我安装好的这个cadance中，virtuoso 打开的是6.1版本，icfb 打开的是5.1版本。6.1版本用的是oa库，5.1版本用的是cdb库，这两个库不兼容，使用时要注意。在此我用的是6.1版本。&lt;/p&gt;

&lt;h2 id=&quot;安装库&quot;&gt;安装库&lt;/h2&gt;

&lt;p&gt;安装时要注意是 cdb 库还是 oa 库。在我电脑中的库中，SMIC_13mmrf_1P6M_30k 是 cdb 库，FreePDK-45 是 OA 库，所以这里我将安装FreePDK库。&lt;/p&gt;

&lt;p&gt;Tools - Library Manager - File - New Library， Directory选择 /path/to/pdk/FreePDK45/ncsu_basekit/lib/，Name 输入NCSU_Devices_FreePDK45，之后 OK。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_New_Library.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在如下对话框中选择 Do not need process information 即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_Technology_File_for_New_Library.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后回到如下界面，在新的Library中出现 cell，即说明安装成功。每一个 cell 都有许多 View。双击一个 view 可浏览，如下图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_Library_Install_Done.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;新建-cellview&quot;&gt;新建 cellview&lt;/h2&gt;

&lt;p&gt;在安装好库后就可以画 cell 了。在画 cell 之前要新建一个库，用于存放我们画的 cell。步骤与上一节相同，只不过我们的路径选择一个空文件夹即可。在这里我新建的库的名字叫 proj1。&lt;/p&gt;

&lt;p&gt;File - New - CellView， Library 选择我们新建的库， cell 起一个名字（这里我要画一个反相器），Type 选择 schematic。OK 之后就会打开一个画图的界面。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_New_File.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;反相器由两个 mos 组成。接下来我们将画这两个 mos 。 Create - Instance， Library 选择 FreePDK 那个库， cell 选择一个mos， View 选择 Symbol， Name 随意取个名字。此时在光标处就会出现一个 mos 管的形状，点击就可以把它放在任何想要的位置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_Add_Instance.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;画好两个 mos 后，接下来增加四个 pin， 分别对应 Vin 、 Vout 、 VDD 、 GND。 Create - Pin ，根据需要选择输入-输出类型，之后添加即可。最后将两个 mos 和四个 pin 用线连接起来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_Inverter_Done.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后 File- Check and Save ，无 error 即可。&lt;/p&gt;

&lt;h2 id=&quot;搭建-inverter-的仿真电路&quot;&gt;搭建 inverter 的仿真电路&lt;/h2&gt;

&lt;p&gt;首先要给我们画的 inverter 创建一个 symbol。这里我们为方便进行自动生成。 Create - CellView - From CellView。 按如下默认设置即可，选择 OK 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_CellView_from_CellView.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;此时在 Library Manager 中，我们发现我们画的 inverter 多了个 symbol 的 view，说明创建成功。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_Add_Symbol_Done.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后我们将搭建 inverter 的仿真电路。同样地，我们新建一个 cellview，我这里取名为 inverter_sim，按下图添加周边电路元件。下面的元件都可以在 basic 库中找到。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_fiugre_Inverter_sim.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;同样地， check and save。&lt;/p&gt;

&lt;h2 id=&quot;spectre-仿真&quot;&gt;Spectre 仿真&lt;/h2&gt;

&lt;p&gt;在我们的 inverter_sim 的原理图界面，Launch - ADE L。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_ADEL.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先添加 model library。Setup - Model Library。 路径为 /path/to/pdk/FreePDK45/ncsu_basekit/models/hspice/tran_models ， 把所有的 .inc 文件添加进去。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_Model_Library_Setup.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Analysis - choose， 这里就和 spice 一样了，选择一种 analysis 。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_Choosing_Analysis.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Simulation - NetList and Run，弹出一个窗口，无 error 和 warning。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_Simulation.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Results - Direct Plot - Main Form，按如下图选择并在原理图中选择一个点来 plot。我这里选择 inverter 的 Vout，直接在原理图上选择对应位置即可。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_Direct_Plot_Form.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后就会弹出一个窗口，就是绘制的曲线。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/others/2_figure_Visualization.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;至此，我们的第一个 candance project 仿真完成。&lt;/p&gt;</content><author><name>Yilong Zhao</name></author><category term="ICDesign" /><category term="ic" /><category term="candance" /><category term="virtuoso" /><summary type="html">Candance的安装</summary></entry><entry><title type="html">VMWare 提示与 Hyper-V冲突；如何在Windows 上彻底关闭Hyper-V</title><link href="http://localhost:4000/2020/07/06/1_Close_Hyper-V/" rel="alternate" type="text/html" title="VMWare 提示与 Hyper-V冲突；如何在Windows 上彻底关闭Hyper-V" /><published>2020-07-06T00:00:00+08:00</published><updated>2020-07-06T00:00:00+08:00</updated><id>http://localhost:4000/2020/07/06/1_Close_Hyper-V</id><content type="html" xml:base="http://localhost:4000/2020/07/06/1_Close_Hyper-V/">&lt;p&gt;前几天看到Windows功能中的虚拟机功能，突然好奇，手贱给打开了，觉得没什么意思，就也没动。直到今天打开VMWare提示与Hyper-V冲突。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;您的主机不满足在启用 Hyper-V 或 Device/Credential Guard 的情况下运行 VMware。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;打开 VMWare 官方文档就是让关闭 Hyper-V。但是其实在我的个人版 Windows 是没有 Hyper-V 选项的。在搜了半天 Hyper-V 是啥才想到可能是和我前几天打开的那个虚拟机功能有关。&lt;/p&gt;

&lt;p&gt;在我关闭这个功能之后，事情并没有改善，我一度以为思路错了，直到我继续谷歌半天才确定就是这个辣鸡虚拟机功能搞的鬼。***&lt;/p&gt;

&lt;h2 id=&quot;解决问题记录&quot;&gt;解决问题记录&lt;/h2&gt;

&lt;p&gt;原因还是 Hyper-V 和 VMWare 不兼容。所以这里实际记录的实际上是如何彻底关闭 Hyper-V。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;小娜-&amp;gt;启用和关闭Windows功能-&amp;gt;关闭 虚拟机平台（或Hyper-V）&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/others/1_figure_windows_function.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;小娜-&amp;gt;计算机管理-&amp;gt;服务和应用程序-&amp;gt;服务-&amp;gt;把所有带 Hyper-V 的停止并禁用。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;/img/others/1_figure_windows_service.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重启计算机&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;问题解决。&lt;/p&gt;</content><author><name>Yilong Zhao</name></author><category term="others" /><category term="record" /><summary type="html">前几天看到Windows功能中的虚拟机功能，突然好奇，手贱给打开了，觉得没什么意思，就也没动。直到今天打开VMWare提示与Hyper-V冲突。</summary></entry></feed>